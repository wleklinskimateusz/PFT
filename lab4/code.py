# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pT1n_MB4y2Ak0BLYeR_QUyInA4TAsk4r
"""

import numpy as np
import matplotlib.pyplot as plt
import sys
import os
plt.style.use("fivethirtyeight")

alfa, m, N = 1.0, 1.0, 50

# path = os.getcwd()
# path = path[:-2]
# sys.path.append(path)


def RK4_vec(t, dt, n, s, func):
    k1 = np.zeros(n)
    k2 = np.zeros(n)
    k3 = np.zeros(n)
    k4 = np.zeros(n)
    w = np.zeros(n)
    for i in range(n):
        w[i] = s[i]
    func(t, w, k1)
    for i in range(n):
        w[i] = s[i] + dt/2 * k1[i]
    func(t + dt/2, w, k2)
    for i in range(n):
        w[i] = s[i] + dt/2 * k2[i]
    func(t + dt/2, w, k3)
    for i in range(n):
        w[i] = s[i] + dt * k3[i]
    func(t + dt, w, k4)
    for i in range(n):
        s[i] += dt/6 * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])


def ex1():

    def derivatives(t: float, s: np.array, k: np.array) -> None:
        alfa, m, N = 1.0, 1.0, 50

        for i in range(1, N):
            k[i] = s[i+N+1]  # x
            k[i+N+1] = (alfa/m)*(s[i-1] - 2*s[i] + s[i+1])  # v

        k[0] = 0
        k[N] = 0
        k[N+1] = 0
        k[2*N+1] = 0

    alfa, m, N = 1.0, 1.0, 50  # N+1 - liczba atomów
    dt, dx = 0.02, 0.1
    n = 5000  # liczba kroków czasowych
    sigma = 3*dx
    t_max = n*dt
    x_max = N*dx
    t_vec = np.linspace(0.0, t_max, n+1)
    x_vec = np.linspace(0, N, N+1)
    s = np.zeros(2*N+2)

    """### 1. Symulacja propagacji zaburzeń w łańcuchu"""

    def init_cond():  # war. początkowy
        for i in range(1, N+1):
            s[i] = i*dx + (dx/3)*np.exp(-((i*dx - 0.5*x_max)**2)/(2*sigma**2))

    x, v, T, U = np.zeros((N+1, n+1)), np.zeros((N+1, n+1)
                                                ), np.zeros(n+1), np.zeros(n+1)
    x_temp = np.copy(x)  # tablica do wychyleń cząstek

    i, t = 0, 0
    init_cond()
    while i <= n:
        RK4_vec(t, dt, 2*N+2, s, derivatives)
        t += dt

        for j in range(N+1):
            x[j][i] = s[j]
            v[j][i] = s[j+N+1]
            x_temp[j][i] = x[j][i] - dx*j

        for k in range(N+1):
            T[i] += 0.5*m*(v[k][i])**2
        i += 1

    i = 0
    while i <= n:
        for k in range(1, N+1):
            U[i] += 0.5*alfa*(x[k-1][i] - x[k][i] + dx)**2
        i += 1

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.plot(t_vec, T, label="Kinetic Energy")
    ax.plot(t_vec, U, label="Potential Energy")
    ax.plot(t_vec, T+U, label="Total Energy")
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Energy [J]')
    fig.legend()
    fig.tight_layout()
    fig.savefig("energy.png")

    fig = plt.figure()
    ax = fig.add_subplot(111)
    im = ax.pcolormesh(t_vec, x_vec, x_temp, shading='auto')
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label('Displacement [m]')
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Equilibrium position [m]')
    fig.tight_layout()
    fig.savefig("displacement.png")


"""### 2. Rezonans mechaniczny"""


def ex2(ver: int = 0):
    alfa, m, N = 1.0, 1.0, 50  # N+1 - liczba atomów
    dt, dx = 0.02, 0.1
    sigma = 3*dx
    x_max = N*dx
    x_vec = np.linspace(0, N, N+1)
    s = np.zeros(2*N+2)

    nn = [0.9, 1.0, 1.1, 1.5, 2.0, 5.0]
    omega_n = [2*np.sqrt(alfa/m)*abs(np.sin(np.pi*nn[i]/(2*N)))
               for i in range(len(nn))]
    t_max = [40*np.pi/(omega_n[i]) for i in range(len(omega_n))]
    n = [int(t_max[i]/dt) for i in range(len(t_max))]  # czas
    t_vec = np.linspace(0.0, t_max[ver], n[ver]+1)

    x, v, T, U = np.zeros(
        (N+1, n[ver]+1)), np.zeros((N+1, n[ver]+1)), np.zeros(n[ver]+1), np.zeros(n[ver]+1)
    x_temp = np.copy(x)  # tablica do wychyleń cząstek

    def init_cond_res():  # war. początkowy
        for i in range(1, N+1):
            s[i] = i*dx

    def derivatives_res(t: float, s: np.array, k: np.array) -> None:
        alfa, m, N, F = 1.0, 1.0, 50, 0.01

        for i in range(1, N):
            k[i] = s[i+N+1]  # x
            k[i+N+1] = (alfa/m)*(s[i-1] - 2*s[i] + s[i+1])  # v

        k[0] = 0
        k[N] = 0
        k[N+1] = 0
        k[2*N+1] = 0
        k[N+2] = (alfa/m)*(s[0] - 2*s[1] + s[2]) + (F/m)*np.sin(omega_n[ver]*t)

    i, t = 0, 0
    init_cond_res()
    while i <= n[ver]:
        RK4_vec(t, dt, 2*N+2, s, derivatives_res)
        t += dt

        for j in range(N+1):
            x[j][i] = s[j]
            v[j][i] = s[j+N+1]
            x_temp[j][i] = x[j][i] - dx*j
        i += 1

    i = 0
    while i <= n[ver]:
        for k in range(N+1):
            T[i] += 0.5*m*(v[k][i])**2
        i += 1

    i = 0
    while i <= n[ver]:
        for k in range(1, N+1):
            U[i] += 0.5*alfa*(x[k-1][i] - x[k][i] + dx)**2
        i += 1

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.plot(t_vec, T, label="Kinetic Energy")
    ax.plot(t_vec, U, label="Potential Energy")
    ax.plot(t_vec, T+U, label="Total Energy")
    ax.grid()
    ax.set_xlabel('t')
    ax.set_ylabel('E')
    fig.legend()
    fig.tight_layout()
    fig.savefig(f'resonance{ver}.png')

    fig = plt.figure()
    ax = fig.add_subplot(111)
    im = ax.pcolormesh(t_vec, x_vec, x_temp)
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label('Displacement [m]')
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Equilibrium position [m]')
    fig.tight_layout()
    fig.savefig(f'resonance{ver}_displacement.png')

# ex1()
for v in range(6):
    ex2(v)